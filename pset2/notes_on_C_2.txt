FOR LANGUAGE C (week 2)


ALGORITHMS SUMMARY

Selection Sort      Find the smallest unsorted element in an array and swap it with the first unsorted element of that array.
Bubble Sort         Swap adjacent pairs of elements if they are out of order, effectively "bubbling" larger elements to the right and smaller ones to the left.
Insertion Sort      Proceed once through the array from left-to-right, shifting elements as necessary to insert each element into its correct place.
Merge Sort          Split the full array into subarrays, then merge those subarrays back together into correct order.
Linear Search       Iterate across the array from left-to-right, trying to find the target element.
Binary Search       Given a sorted array, divide and conquer by systematically elimination half of the remaining elements in the search for the target element.



ARRAYS

  * Arrays are fundamental data structure, and they are extremely useful.
  * We use arrays to hold values of the same type at contiguous memory locations.
  * One way to analogize the notion of array is to think of your local post office, which usually has a large bank of post office boxes.

  * In C, elements of an array are indexed starting from 0.
    * This is one of the major reasons we count from zero!
  * If an array consists of n elements, the first element is located at index 0. The last element is located at index(n-1).
  * C is very lenient. It will not prevent you from going "out of bounds" of your array; be careful.

  * Array declarations

      type name[size];

      examples:

      int student_grades[40];
      double menu_prices[8];

  * The type is what kind of cariable each element of the array will be.
  * The name is what you want to call your array.
  * The size is how many elements you would like your array to contain.

  * If you think of a single element of an array of type data-type the same as you would any other variable of type data-type (which, effectively, it is) then all the familiar operations make sense.

      bool truthtable[10];

      truthtable[2] = false;
      if(truthtable[7] == true)
      {
        printf("TRUE!\n");
      }
      truthtable[10] = true; // as we are counting from 0 and our array has 10 elements, using 10th element here can be problematic, and 9 should be used.

  * When declaring and initializing an array simultaneously, tere is a special syntax that may be used to fill up the array with its starting values.

      // instantiation syntax
      bool truthtable[3] = { false, true, true };

      // individual element syntax
      bool truthtable[3];
      truthtable[0] = false;
      truthtable[1] = true;
      truthtable[2] = true;

  * When declaring and initializing an array simultaneously, there is a special sytax that may be used to fill up the array with its starting values.

      // instantiation syntax
      bool truthtable[] = { false, true, true };

  * Arrays can consist of more than a single dimension. You can have as many size specifiers as you wish.

      bool battleship[10][10];

  * You can choose to think of this as either a 10x10 grid of cells.
    * In memory though, it's really just a 100-element one-dimensional array.
    * Multi-dimensional arrays are reat abstractions to help visualize game boards or other complex representations.

  * While we can treat individual elements of arrays as variables, we cannot treat the entire array themselves as variables.
  * We cannot, for instance, assign one array to another using the assignment operator. This is not legal C.
  * Instead, we must use a loop to copy over the elements one at a time.

      int foo[5] = { 1, 2, 3, 4, 5 };
      int bar[5];

      for (int j = 0; j < 5; j++)
      {
        bar[j] = foo[j];
      }

  * Recall that most variable in C are passed by value in function calls.
  * Arrays do not follow this rule. Rather they are passed by reference. The calee recieves the actual array, not a copy of it.
  * For now, we will gloss over why arrays have this special property, but we'll return to it soon enough!

      void set_array(int array[4]);
      void set_int(int x);

      int main(void)
      {
        int a = 10;
        int b[4] = { 0, 1, 2, 3 };
        set_int(a);
        set_array(b);
        printf("%d %d\n", a, b[0]);  // printf will print 10, 22
      }

      void set_array(int array[4])
      {
        array[0] = 22;
      }

      void set_int(int x)
      {
        x = 22;
      }



LINEAR SEARCH

  * In linear search, the idea of the algorithm is to iterate across the array from left to right, searching for a specified element.

  * In pseudocode:
    * Repeat, starting at the first elemnt:
      * If the first element is what you're looking for (the target). stop.
      * Otherwise, move to the next element.

  * Worst-case scenario: We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all.
  * Best-case scenario: The target element is the first element of the array, and so we can stop looking immediately after we start.



BINARY SEARCH

  * In binary search, the idea of algorithm is to divide and conquer, reducing the search area by half each time, trying to find a target number.
    * In order to leverage this power however, our array must first be sorted, else we cannot make assumptions about the array's contents.

  * In pseudocode:
    * Repeat until (sub)array is of size 0:
      * Calculate the middle point of the current (sub)array.
      * If the target is at the middle, stop.
      * Otherwise, if the target is less than what's at the middle, repeat, changing the end point to be just to the left of the middle.
      * Otherwise, if the target is greatere than what's at the middle, repeat, changing the start point to be just to the right of the middle.

  * Worst-case scenario: We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or diesn't exist in the array at all.
  * Best-case Scenario: The target element is at the midpoint of full array, and so we can stop loking immediately after we start.



BUBBLE SORT

  * In bubble sort, the idea of the algorithm is to move higher valied elements generally to the right and lower valued elements generally to the left.

  * In pseudocode:
    * Set swap counter to a non-zero value.
    * Repeat until the swap counter is 0.
      * Reset swap counter to 0.
      * Look at each adjacent pair.
        * If two adjacent elements are not in order, swap them and add one to the swap counter.

  * Worst-case scenario: The array is in reverse order; we have to "bubble" each of the n elements all the way across the array, and since we can only fully bubbble ne element into position per pass, we must do this n times.
  * Best-case scenario: The aray is already perfectly sorted, and we make no swaps on the first pass.



INSERTION SORT

  * In insertion sort, the idea of the algorithm is to build your sorter array in place, shifting elements out of the way if necessary to make room as you go.

  * In pseudocode:
    * Call the first element of the array "sorted".
    * Repeat until all elements are sorted:
      * Look at the next unsorted element. Insert into the "sorted" portion by shifting the requisite number of elements.

  * Worst-case scenario: The array is in reverse order; we ave to shift each of the n elements n positions each time we make an insertion.
  * Best-case scenario: The array is already perfectly sorted, and we simply keep moving the line betwwen "unsorted" and 'sorted' as we examine each element.



MERGE SORT

  * In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order.
  * Merge sort leverages something called recursion, which we'll touch on in more detail in future.

  * In pseudocode:
    * Sort the elft half of the array (assuming n > 1).
    * Sort the right hal of the array (assuming n > 1).
    * Merge the two halves together.

  * Worst-case scenario: We have to split n elements up and recombine them, effectively doubling the sorted subarrays as we build them  up (combining sorted 1-element arrays into 2-element arrays, combining sorted 2-element arrays into 4-element arrays...).
  * Best-case scenario: The array is already perfectly sorted. But we still have to split and recombine it back together with this algorighm.



SELECTION SORT

  * In the selection sort, the idea of the algoriht is to find the smallest unsorted element and add it to the end of the sorted list.

  * In pseudocode:
    * Repeat until no unsorted elements remain:
      * Search the unsorted part of the data to find the smallest value.
      * Swap the smallest found value with the first element of the unsorted part.

  * Worst-case scenario: We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass.
  * Best-case scenario: Exactly the same! There's no way to gurantee the array is sorted until we go through this process for all the elements.
