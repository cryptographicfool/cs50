FOR LANGUAGE C (week 3)


CALL STACKS

- When you call a function, the system sets aside space in memory for that function to do its necessary work.
  - We frequently call such chunks of memory stack frames or function frames.
- More than one function's stack frame may exist in memory at a given time. If main() calls move(), which then calls direction(), all three functions have open frames.
- These frames are arranged in a stack. The frame for the most-recently called function is always on the top of the stack.
- When a new function is called, a new frame is pushed onto the top of the stack and becomes the active frame.
- When a function finishes its work, the frame is popped off of the stack, and the frame immediately below it becomes the new, active, function on the top of the stack.



FILE POINTERS

- The ability to read data from and write data to files is the primary means of storing persistent data, data that does not disappear when your program stops running.
- The abstraction of files that C provides is implemented in a data stricture known as a FILE.
  - Almost universally, when working with files, we will be using pointers to them, FILE*.
- The file manipulation functions all live in stdio.h.
  - All of them accept FILE* as one of their parameters, except for the function fopen(), which is used to get a file pointer in the first place.
- Some of the most common file input/output (I/O) functions that we'll be working with are:
  - fopen()
  - fclose()
  - fgetc()
  - putc()
  - fread()
  - fwrite()


- fopen()
  - Opens a file and returns a file pointer to it.
  - Always check the return value to make sure you don't get back a NULL.

    FILE* ptr = fopen(<filename>, <operation>);

    // or

    FILE* ptr1 = fopen("file1.txt", "r"); // here r means that we want to read the file
    FILE* ptr2 = fopen("file2.txt", "w"); // here w means that we want to write to the file
    FILE* ptr3 = fopen("file3.txt", "r"); // here a means that we want to append to the file
    // write overwrites while append adds to the end of the file


- fclose()
  - Closes the file pointed to by the given file pointer.

    fclose(<file pointer>);

    // or

    fclose(ptr1);


- fgetc()
  - Reads and returns the next character from the file pointed to.
  - Note: The operation of the file pointer passed in as a parameter must be "r" for read, or you will suffer an error.

    char ch = fgetc(<file pointer>);

    // or

    char ch = fgetc(ptr1);

  - The ability to get single characters from files, if wrapped in a loop, means we could read all the characters from a file and print them to the screen, one-by-one, essentially.

    char ch;
    while((ch = fgetc(ptr)) != EOF)     // EOF, defined in stdio.h means end of file
    {
        printf("%c", ch);
    }

  - We might put this in a file called cat.c, after the linux command "cat" which essentially does just this.


- fputc()
  - Writes or appends the specified character to the pointed-to file.
  - Note: The operation of the file pointer passed in as parameter must be "w" for write, or "a" for append, or you will suffer an error.

    fputc(<character>, <file pointer>);

    // or

    fputc('A', ptr2);

    // or

    fputc('!', ptr3);

  - Now that we can read characters from files and write to characters to them. Let's extend our previous example to copy one file to another, instead of printing to the screen.

    char ch;
    while((ch = fgetc(ptr)) != EOF)
    {
        fput(ch, ptr2);
    }

  - We might put this in a file called cp.c, after the Linux command "cp" which essentially does this.


- fread()
  - Reads <qty> units of size <size> from the file pointed to and stores them in a buffer (usually an array) pointed to by <buffer>/
  - Note: The operation for the file pointer passed in as a parameter must be "r" for read or you will suffer an error.

    fread(<buffer>, <size>, <qty>, <file pointer>);

    // or

    int arr[10];
    fread(arr, sizeof(int), 10, ptr);

    // or with dynamically allocated buffer

    double* arr2 = malloc(sizeof(double) * 80);
    fread(arr2, sizeof(double), 80, ptr);

    // or to get 1 character

    char c;
    fread(&c, sizeof(char), 1, ptr);


- fwrite()
  - Writes <qty> units of <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer>.
  - Note: The operation of the file pointer passed in as a parameter must be "w" for write or "a" for append, or you will suffer an error.

    fwrite(<buffer>, <size>, <qty>, <file pointer>);

    // or

    int arr[10];
    fwrite(arr, sizeof(int), 10, ptr);

    // or with dynamically allocated buffer

    double* arr2 = malloc(sizeof(double) * 80);
    fwrite(arr2, sizeof(double), 80, ptr);

    // or to write 1 character

    char c;
    fwrite(&c, sizeof(char), 1, ptr);


- Lots of other useful functions are abound in stdio.h for you to work with. Here are some more of the useful ones.
  - fgets()   :   Reads a full string from a file.
  - fputs()   :   Writes a full string to a file.
  - fprintf() :   Writes a formatted string to a file.
  - fseek()   :   Allows you to rewind or fast forward within a file.
  - ftell()   :   Tells you at what (byte) position you are at within a file.
  - feof()    :   Tells you whether you've read to the end of a file.
  - ferror()  :   Indicates whether an error has occurred in working with a file.



DYNAMIC MEMORY ALLOCATION
